<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>3D City</title>
    <style>
#container {
  background: #66ccff;
  width: 1000px;
  height: 1000px;
}
    </style>
</head>
<body>
  <div id="container">
  </div>
</body>
<!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script> -->
<script src="jquery-1.5.1.min.js"></script>
<script src="Three.js"></script>
<script src="webgl-utils.js"></script>
<script type="text/javascript">

var TWO_PI = 2 * Math.PI;
var LOT_WIDTH = 1;
var LOT_DEPTH = 1;
var STREET_WIDTH = 2;
var STREET_DEPTH = 2;
var BLOCK_WIDTH = 4;
var BLOCK_DEPTH = 4;
var BLOCK_ROWS = 60;
var BLOCK_COLUMNS = 20;
var MIN_BUILDING_HEIGHT = 0.5;
var MAX_BUILDING_HEIGHT = 20;
var MAX_BUILDING_MATERIALS = 50;
var TOTAL_SCENE_WIDTH = (BLOCK_WIDTH * BLOCK_ROWS) + (STREET_WIDTH * (BLOCK_ROWS - 1));
var HALF_SCENE_WIDTH = TOTAL_SCENE_WIDTH / 2;
var TOTAL_SCENE_DEPTH = (BLOCK_DEPTH * BLOCK_COLUMNS) + (STREET_DEPTH * (BLOCK_COLUMNS - 1));
var HALF_SCENE_DEPTH = TOTAL_SCENE_DEPTH / 2;

var renderer, scene, camera;

function initScene() {
  var WIDTH = 1000, HEIGHT = 1000;

  // Build renderer
  renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(WIDTH, HEIGHT);

  var $container = $('#container');
  $container.append(renderer.domElement);

  // Build scene
  scene = new THREE.Scene();
  
  var originMaterial = new THREE.MeshLambertMaterial({ color: 0xf32920 });
  var origin = new THREE.Mesh(new THREE.SphereGeometry(0.5, 10, 10), originMaterial);
  scene.add(origin);

  var groundMaterial = new THREE.MeshBasicMaterial({ color: 0x777777 });
  var ground = new THREE.Mesh(new THREE.PlaneGeometry(TOTAL_SCENE_WIDTH * 5, TOTAL_SCENE_DEPTH * 5), groundMaterial);
  ground.rotation.x = -(TWO_PI / 4);
  scene.add(ground);

  var buildingMaterials = [];
  var buildingGeometries = [];
  for (var i = 0; i < MAX_BUILDING_MATERIALS; i++) {
    var r = Math.random();
    var g = Math.random();
    var b = Math.random();
    var buildingColor = new THREE.Color(0xffffff);
    buildingColor.setRGB(r, g, b);

    buildingMaterials.push(new THREE.MeshLambertMaterial({ color: buildingColor.getHex() }));
    buildingGeometries.push(new THREE.Geometry());
  }

  var BLOCK_LAYOUTS = [
                        [ { width: 1.0, depth: 1.0, offsetFromBlockCenterX: 0.0, offsetFromBlockCenterZ: 0.0 } ],
                        [ { width: 0.5, depth: 1.0, offsetFromBlockCenterX: -0.5, offsetFromBlockCenterZ: 0.0 },
                          { width: 0.5, depth: 1.0, offsetFromBlockCenterX: 0.5, offsetFromBlockCenterZ: 0.0 } ],
                        [ { width: 1.0, depth: 0.5, offsetFromBlockCenterX: 0.0, offsetFromBlockCenterZ: -0.5 },
                          { width: 1.0, depth: 0.5, offsetFromBlockCenterX: 0.0, offsetFromBlockCenterZ: 0.5 } ],
                        [ { width: 0.5, depth: 1.0, offsetFromBlockCenterX: -0.5, offsetFromBlockCenterZ: 0.0 },
                          { width: 0.5, depth: 0.5, offsetFromBlockCenterX: 0.5, offsetFromBlockCenterZ: -0.5},
                          { width: 0.5, depth: 0.5, offsetFromBlockCenterX: 0.5, offsetFromBlockCenterZ: 0.5} ],
                        [ { width: 0.5, depth: 0.5, offsetFromBlockCenterX: -0.5, offsetFromBlockCenterZ: -0.5 },
                          { width: 0.5, depth: 0.5, offsetFromBlockCenterX: -0.5, offsetFromBlockCenterZ: 0.5},
                          { width: 0.5, depth: 0.5, offsetFromBlockCenterX: 0.5, offsetFromBlockCenterZ: -0.5},
                          { width: 0.5, depth: 0.5, offsetFromBlockCenterX: 0.5, offsetFromBlockCenterZ: 0.5} ],
                        [ { width: (1 / 3), depth: 0.5, offsetFromBlockCenterX: -(2 / 3), offsetFromBlockCenterZ: 0.5 },
                          { width: (1 / 3), depth: 0.5, offsetFromBlockCenterX: 0.0, offsetFromBlockCenterZ: 0.5},
                          { width: (1 / 3), depth: 0.5, offsetFromBlockCenterX: (2 / 3), offsetFromBlockCenterZ: 0.5},
                          { width: 0.5, depth: 0.5, offsetFromBlockCenterX: -0.5, offsetFromBlockCenterZ: -0.5},
                          { width: 0.5, depth: 0.5, offsetFromBlockCenterX: 0.5, offsetFromBlockCenterZ: -0.5} ],
                      ];

  // Loop through the lower left corner of each block
  for (var i = -(HALF_SCENE_WIDTH); i < HALF_SCENE_WIDTH; i += BLOCK_WIDTH + STREET_WIDTH) {
    for (var j = -(HALF_SCENE_DEPTH); j < HALF_SCENE_DEPTH; j += BLOCK_DEPTH + STREET_DEPTH) {

      var building;
      var blockLayout = BLOCK_LAYOUTS[Math.floor(Math.random() * BLOCK_LAYOUTS.length)];
      for (var layoutIndex = 0; layoutIndex < blockLayout.length; layoutIndex++) {
        var lotLayout = blockLayout[layoutIndex];
        var maxHeightI = MAX_BUILDING_HEIGHT * ((HALF_SCENE_WIDTH - Math.abs(i)) / HALF_SCENE_WIDTH);
        var maxHeightJ = MAX_BUILDING_HEIGHT * ((HALF_SCENE_DEPTH - Math.abs(j)) / HALF_SCENE_DEPTH);
        var maxHeight = Math.min(maxHeightI, maxHeightJ);
        var buildingHeight = Math.floor((Math.random() * maxHeight - MIN_BUILDING_HEIGHT)) + MIN_BUILDING_HEIGHT;

        building = new THREE.Mesh(new THREE.CubeGeometry(lotLayout.width * BLOCK_WIDTH, 1, lotLayout.depth * BLOCK_WIDTH));
      
        building.position.x = i + BLOCK_WIDTH / 2 + ((BLOCK_WIDTH / 2) * lotLayout.offsetFromBlockCenterX);
        building.scale.y =  (Math.random() * maxHeight) + MIN_BUILDING_HEIGHT;
        building.position.y = building.scale.y / 2;
        building.position.z = j + BLOCK_DEPTH / 2 + ((BLOCK_DEPTH / 2) * lotLayout.offsetFromBlockCenterZ);

        var index = Math.floor(Math.random() * MAX_BUILDING_MATERIALS);
        THREE.GeometryUtils.merge(buildingGeometries[index], building); 
      }
    }
  }

  for (var i = 0; i < MAX_BUILDING_MATERIALS; i++) {
    scene.add(new THREE.Mesh(buildingGeometries[i], buildingMaterials[i]));
  }

  // Build camera
  var VIEW_ANGLE = 45, ASPECT = WIDTH / HEIGHT, NEAR = 0.1, FAR = 10000;
  camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
  camera.lookAt(scene.position);
  camera.position.x = 0;
  camera.position.y = 5;
  camera.position.z = HALF_SCENE_DEPTH + 90;

  // Build light sources
  var pointLight1 = new THREE.PointLight(0xffffff);
  pointLight1.position.x = 0;
  pointLight1.position.y = 0;
  pointLight1.position.z = 100000;

  var pointLight2 = new THREE.PointLight(0xffffff);
  pointLight2.position.x = 0;
  pointLight2.position.y = 20;
  pointLight2.position.z = 0;


  scene.add(camera);
  scene.add(pointLight1);
  scene.add(pointLight2);
  renderer.render(scene, camera);

  animate();
}

var CAMERA_Z_DELTA = 0.2;
var CAMERA_X_DELTA = 0.2;
var SWOOP_DESCENT_DELTA = 0.011;
var SWOOP_SPEED_DELTA = 0.00003;
var PATH = [[0, -1], [-2, -1], [-2, -2], [2, -2], [2, 1], [3, 1], [3, 3], [0, 3]];

var deltaX = 0.0;
var deltaZ = CAMERA_Z_DELTA;
var rotation_progress = 0.0;
var rotation_target = 0;
var pathIndex = 0;
var targetX;
var targetZ;
var targetAngle = 0;
var ROTATION_DELTA = 0.05;
var deltaAngle = ROTATION_DELTA;
var RIGHT_ANGLE = Math.PI / 2;

var animator = new swoopAnimation();
function animate() {
  animator.animate();

  if (animator.finished == true) {
    if (animator instanceof swoopAnimation || animator instanceof forwardAnimation) {
      animator = new rotationAnimation();
    }
    else if (animator instanceof rotationAnimation) {
      animator = new forwardAnimation();
    }
  }

  renderer.render(scene, camera);
  requestAnimFrame(animate);
}

function swoopAnimation() {
  this.finished = false;
}

swoopAnimation.prototype.animate = function() {
  camera.position.y -= SWOOP_DESCENT_DELTA;
  camera.position.z -= deltaZ;

  if (camera.position.z <= (HALF_SCENE_DEPTH + (STREET_WIDTH / 2))) {
    camera.position.z = HALF_SCENE_DEPTH + (STREET_WIDTH / 2);
    this.finished = true;
  }
}

function forwardAnimation() {
  this.finished = false;
}

forwardAnimation.prototype.animate = function() {
  camera.position.x += deltaX;
  camera.position.z += deltaZ;

  if ((deltaX < 0 && camera.position.x < targetX) || (deltaX > 0 && camera.position.x > targetX) ||
      (deltaZ < 0 && camera.position.z < targetZ) || (deltaZ > 0 && camera.position.z > targetZ)) {
    pathIndex += 1;
    if (pathIndex >= PATH.length) {
      pathIndex = 0;
    }

    camera.position.x = targetX;
    camera.position.z = targetZ;

    this.finished = true;
  }
}

function rotationAnimation() {
  targetX = (PATH[pathIndex][0] * BLOCK_WIDTH) + (PATH[pathIndex][0] * STREET_WIDTH);
  targetZ = (PATH[pathIndex][1] * BLOCK_WIDTH) + (PATH[pathIndex][1] * STREET_WIDTH);
  deltaX = (camera.position.x == targetX) ? 0 : 0.2;
  deltaZ = (camera.position.z == targetZ) ? 0 : 0.2;
  deltaX *= (camera.position.x > targetX) ? -1 : 1;
  deltaZ *= (camera.position.z > targetZ) ? -1 : 1;

  var oldTargetAngle = targetAngle;
  if (deltaX != 0 && oldTargetAngle == 0) {  // NORTH
    targetAngle = (deltaX < 0) ? targetAngle + RIGHT_ANGLE : targetAngle - RIGHT_ANGLE;
  }
  else if (deltaZ != 0 && (oldTargetAngle == RIGHT_ANGLE || oldTargetAngle == ((-3 * Math.PI) / 2))) {  // EAST
    targetAngle = (deltaZ < 0) ? targetAngle - RIGHT_ANGLE : targetAngle + RIGHT_ANGLE;
  }
  else if (deltaX != 0 && (oldTargetAngle == Math.PI || oldTargetAngle == Math.PI * -1)) {  // SOUTH
    targetAngle = (deltaX < 0) ? targetAngle - RIGHT_ANGLE : targetAngle + RIGHT_ANGLE;
  }
  else if (deltaZ != 0 && (oldTargetAngle == Math.PI / -2 || oldTargetAngle == (Math.PI * 3) / 2)) {  // WEST
    targetAngle = (deltaZ < 0) ? targetAngle + RIGHT_ANGLE : targetAngle - RIGHT_ANGLE;
  }

  deltaAngle = ROTATION_DELTA;
  deltaAngle *= (targetAngle > oldTargetAngle) ? 1 : -1;

  this.finished = false;
}

rotationAnimation.prototype.animate = function() {
  camera.rotation.y += deltaAngle;
  
  if ((deltaAngle < 0 && camera.rotation.y <= targetAngle) || (deltaAngle > 0 && camera.rotation.y >= targetAngle)) {
    if (targetAngle >= Math.PI * 2 || targetAngle <= Math.PI * -2) {
      targetAngle = 0;
    }

    camera.rotation.y = targetAngle;
    this.finished = true;
  }
}

initScene();
</script>
</html>
