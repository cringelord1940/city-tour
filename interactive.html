<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>City Tour Interactive</title>
    <style>
html {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  height: 100%;
  font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Helvetica", arial, sans-serif;
  font-size: 16px;
  line-height: 1.5rem;
  color: #2a2b2b;
}

label {
  width: 6.0rem;
  display: inline-block;
}

h3 {
  font-size: 1.25rem;
  margin: 0;
}

.section {
  margin-bottom: 1.5rem;
}

input[type="range"] {
  vertical-align: sub;
}

.control-legend {
  display: inline-block;
  width: 1.5rem;
  text-align: center;
}

.full-width { width: 100%; }
.full-height { height: 100%; }
.relative { position: relative; }
.absolute { position: absolute; }
.block { display: block; }
.display-none { display: none; }
.center { text-align: center; }
.no-underline { text-decoration: none; }
    </style>
</head>
<body>
  <div id="container" class="full-width full-height">
    <div id="city-editor-container" class="absolute" style="top: 0; right: 0; background: #fff; padding: 1.5rem;">
      <div style="overflow: auto;">
        <a id="city-editor-toggle" href="#" class="no-underline" style="float: right; color: #000;">â˜°</a>
      </div>
      <div id="city-editor" class="display-none">
        <div class="section">
          <h3>Terrain</h3>
          <span class="block">
            <label>Jitter</label>
            <span class="control-legend">&minus;</span>
            <input id="terrain-jitter" type="range" value="20" min="0" max="100" step="1" />
            <span class="control-legend">+</span>
          </span>
          <span class="block">
            <label>Decay</label>
            <span class="control-legend">&minus;</span>
            <input id="terrain-decay" type="range" value="0.65" min="0.0" max="1.0" step="0.01" />
            <span class="control-legend">+</span>
          </span>
          <span class="block">
            <label>River</label>
            <input id="terrain-river" type="checkbox" checked />
          </span>
        </div>

        <div class="section">
          <h3>Roads</h3>
          <span class="block">
            <label>Decay</label>
            <span class="control-legend">&minus;</span>
            <input id="roads-decay-distance-percentage" type="range" value="0.4" min="0.0" max="0.99" step="0.01" />
            <span class="control-legend">+</span>
          </span>
        </div>

        <div class="section">
          <h3>Buildings</h3>
          <span class="block">
            <label>Max Stories</label>
            <span class="control-legend">&minus;</span>
            <input id="buildings-max-stories" type="range" value="40" min="1" max="80" step="1" />
            <span class="control-legend">+</span>
          </span>
          <span class="block">
            <label>Density</label>
            <span class="control-legend">&minus;</span>
            <input id="buildings-decay-distance-percentage" type="range" value="0.4" min="0.0" max="1.0" step="0.01" />
            <span class="control-legend">+</span>
          </span>
        </div>

        <span class="block center">
          <button id="reset" style="margin-left: auto; margin-right: auto;">Create New City</button>
        </span>
      </div>
    </div>


    <div class="absolute" style="bottom: 0; right: 0; background: #fff; padding: 1.5rem;">
      <button id="flythrough-toggle">Take a Tour</button>
      <div id="navigation-controls-container">
        <span class="block" style="display: none;">
          <label>X:</label>
          <input id="centerX" type="range" value="0.0" min="-1000.0" max="1000.0" step="0.1" />
        </span>
        <span class="block" style="display: none;">
          <label>Z:</label>
          <input id="centerZ" type="range" value="0.0" min="-1000.0" max="1000.0" step="0.1" />
        </span>
        <span class="block">
          <label>Rotation</label>
          <span class="control-legend">&olarr;</span>
          <input id="rotationY" type="range" value="-0.5235987755983" min="-3.141592653589793" max="3.141592653589793" step="0.001" />
          <span class="control-legend">&orarr;</span>
        </span>
        <span class="block">
          <label>Tilt</label>
          <span class="control-legend">&rarr;</span>
          <input id="rotationX" type="range" value="0.2" min="0.0" max="1.0" step="0.001" />
          <span class="control-legend">&darr;</span>
        </span>
        <span class="block">
          <label>Zoom</label>
          <span class="control-legend">&minus;</span>
          <input id="zoom" type="range" value="0.0" min="0.0" max="1.0" step="0.01" />
          <span class="control-legend">+</span>
        </span>
      </div>
    </div>
  </div>
</body>
<script src="lib/three-v86.min.js" type="text/javascript"></script>
<script src="lib/analytics.js" type="text/javascript"></script>
<script src="city_tour.js" type="text/javascript"></script>
<script type="text/javascript">
"use strict";

var InteractiveCamera = function(messageBroker) {
  var TWO_PI = Math.PI * 2;

  var MIN_CENTER_X = -1000.0;
  var MAX_CENTER_X = 1000.0;

  var MIN_CENTER_Z = -1000.0;
  var MAX_CENTER_Z = 1000.0;

  var MIN_TILT_ANGLE = -1.5707963267949;
  var MAX_TILT_ANGLE = -0.1;

  var MIN_ZOOM_DISTANCE = 20.0;
  var MAX_ZOOM_DISTANCE = 1000.0;

  var centerX = 0.0;
  var centerZ = 0.0;
  var zoomPercentage = 0.0;
  var tiltPercentage = 0.2;
  var rotationAngle = 0.0;

  var clamp = function(value, min, max) {
    return Math.max(min, Math.min(max, value));
  };

  var interactiveCamera = {};

  interactiveCamera.centerX = function() { return centerX; };
  interactiveCamera.centerZ = function() { return centerZ; };
  interactiveCamera.setCenterCoordinates = function(newCenterX, newCenterZ) {
    centerX = clamp(newCenterX, MIN_CENTER_X, MAX_CENTER_X);
    centerZ = clamp(newCenterZ, MIN_CENTER_Z, MAX_CENTER_Z);
    messageBroker.publish("camera.updated", {});
  };

  interactiveCamera.zoomPercentage = function() { return zoomPercentage; };
  interactiveCamera.setZoomPercentage = function(newZoomPercentage) {
    zoomPercentage = clamp(newZoomPercentage, 0.0, 1.0);
    messageBroker.publish("camera.updated", {});
  };

  interactiveCamera.tiltPercentage = function() { return tiltPercentage; };
  interactiveCamera.setTiltPercentage = function(newTiltPercentage) {
    tiltPercentage = clamp(newTiltPercentage, 0.0, 1.0);
    messageBroker.publish("camera.updated", {});
  };

  interactiveCamera.rotationAngle = function() { return rotationAngle; };
  interactiveCamera.setRotationAngle = function(newRotationAngle) {
    rotationAngle = newRotationAngle;

    if (rotationAngle < -Math.PI) {
      rotationAngle += TWO_PI;
    }
    else if (rotationAngle > Math.PI) {
      rotationAngle -= TWO_PI;
    }

    messageBroker.publish("camera.updated", {});
  };


  /*    C
       /|
      / |
     /  |
    X----

  X == Map center point
  C == Camera position
  rotationX == angle X == angle between camera and center point
  Hypotenuse == Zoom == Distance of camera from center point
  Opposite == Height of camera off the ground
  Adjacent == X/Z distance of camera from center point
  rotationY == rotation of this triangle around y-axis of center point
  */
  interactiveCamera.syncCamera = function(poleCamera) {
    var tiltAngle = CityTour.Math.lerp(MAX_TILT_ANGLE, MIN_TILT_ANGLE, tiltPercentage);
    var zoom = CityTour.Math.lerp(MAX_ZOOM_DISTANCE, MIN_ZOOM_DISTANCE, zoomPercentage);

    var hypotenuse = zoom;
    var adjacent = Math.cos(tiltAngle) * hypotenuse;
    var opposite = -(Math.sin(tiltAngle) * hypotenuse);

    poleCamera.setPositionX(centerX + (adjacent * Math.sin(rotationAngle)));
    poleCamera.setPositionY(opposite);
    poleCamera.setPositionZ(centerZ + (adjacent * Math.cos(-rotationAngle)));
    poleCamera.setRotationX(tiltAngle);
    poleCamera.setRotationY(rotationAngle);
  };

  interactiveCamera.syncFromPoleCamera = function(poleCamera) {
    rotationAngle = poleCamera.rotationY();
    var tiltAngle = Math.min(MAX_TILT_ANGLE, poleCamera.rotationX());
    tiltPercentage = (tiltAngle - MAX_TILT_ANGLE) / (MIN_TILT_ANGLE - MAX_TILT_ANGLE);

    var opposite = poleCamera.positionY();
    var hypotenuse = (1 / Math.sin(-tiltAngle)) * opposite;
    var adjacent = Math.sqrt((hypotenuse * hypotenuse) - (opposite * opposite));

    centerX = poleCamera.positionX() - (adjacent * Math.sin(rotationAngle));
    centerZ = poleCamera.positionZ() - (adjacent * Math.cos(rotationAngle));
    zoomPercentage = 1.0 - ((hypotenuse - MIN_ZOOM_DISTANCE) / (MAX_ZOOM_DISTANCE - MIN_ZOOM_DISTANCE));

    messageBroker.publish("camera.updated", {});
  };

  return interactiveCamera;
};


var NavigationController = function(interactiveCamera, messageBroker) {
  var container = document.getElementById("navigation-controls-container");
  var centerXControl = document.getElementById("centerX");
  var centerZControl = document.getElementById("centerZ");
  var rotationYControl = document.getElementById("rotationY");
  var rotationXControl = document.getElementById("rotationX");
  var zoomControl = document.getElementById("zoom");

  var render = function(data) {
    centerXControl.value = interactiveCamera.centerX();
    centerZControl.value = interactiveCamera.centerZ();
    rotationYControl.value = interactiveCamera.rotationAngle();
    rotationXControl.value = interactiveCamera.tiltPercentage();
    zoomControl.value = interactiveCamera.zoomPercentage();
  };

  var setCenterCoordinates = function(e) {
    interactiveCamera.setCenterCoordinates(parseFloat(centerXControl.value), parseFloat(centerZControl.value));
  };
  var setRotationAngle = function(e) {
    interactiveCamera.setRotationAngle(parseFloat(rotationYControl.value));
  };
  var setTiltAngle = function(e) {
    interactiveCamera.setTiltPercentage(parseFloat(rotationXControl.value));
  };
  var setZoomPercentage = function(e) {
    interactiveCamera.setZoomPercentage(parseFloat(zoomControl.value));
  };

  var onFlythroughStarted = function(e) {
    container.classList.add("display-none");
  };

  var onFlythroughStopped = function(e) {
    container.classList.remove("display-none");
  };

  centerXControl.addEventListener('input', setCenterCoordinates, false);
  centerZControl.addEventListener('input', setCenterCoordinates, false);
  rotationYControl.addEventListener('input', setRotationAngle, false);
  rotationXControl.addEventListener('input', setTiltAngle, false);
  zoomControl.addEventListener('input', setZoomPercentage, false);

  render({});

  var id1 = messageBroker.addSubscriber("camera.updated", render);
  var id2 = messageBroker.addSubscriber("flythrough.started", onFlythroughStarted);
  var id3 = messageBroker.addSubscriber("flythrough.stopped", onFlythroughStopped);
};


var NavigationTouchController = function(el, interactiveCamera, messageBroker) {
  var PAN = 1;
  var TILT = 2;
  var ROTATE = 3;
  var PINCH_ZOOM = 4;

  var currentGesture;
  var previousTouchPoints;

  var onMouseDown = function(e) {
    previousTouchPoints = [{x: e.clientX, z: e.clientY}];
  };

  var onTouchStart = function(e) {
    var i, touch;

    previousTouchPoints = [];
    for (i = 0; i < e.touches.length; i++) {
      touch = e.touches.item(i);
      previousTouchPoints.push({x: touch.clientX, z: touch.clientY});
    }

    e.preventDefault();
  };

  var onTouchStartStub = function(e) {
    e.preventDefault();
  };

  var onMouseMove = function(e) {
    if (previousTouchPoints < 1) {
      return;
    }

    processGesture([{x: e.clientX, z: e.clientY}]);
  };

  var onTouchMove = function(e) {
    var i, touch;
    var currentTouchPoints;

    currentTouchPoints = [];
    for (i = 0; i < e.touches.length; i++) {
      touch = e.touches.item(i);
      currentTouchPoints.push({x: touch.clientX, z: touch.clientY});
    }

    processGesture(currentTouchPoints);
  };

  var onMouseUp = function(e) {
    currentGesture = undefined;
    previousTouchPoints = [];
  };

  var onTouchEnd = function(e) {
    currentGesture = undefined;
    previousTouchPoints = [];
  };

  var panCamera = function(currentTouchPoints) {
    var rotationY = interactiveCamera.rotationAngle();
    var dragXDistanceInPixels = currentTouchPoints[0].x - previousTouchPoints[0].x;
    var dragZDistanceInPixels = currentTouchPoints[0].z - previousTouchPoints[0].z;
    var dragAngle = Math.atan2(-dragZDistanceInPixels, -dragXDistanceInPixels);

    // Scale the drag distance based on the camera zoom. If zoomed in, dragging should
    // move the camera less than if the camera is zoomed out.
    var zoomMultiplier = (((1 - interactiveCamera.zoomPercentage()) * 0.92)) + 0.08;
    var totalDragDistanceInPixels = Math.sqrt((dragXDistanceInPixels * dragXDistanceInPixels) + (dragZDistanceInPixels * dragZDistanceInPixels));
    var scaledDragDistanceInPixels = totalDragDistanceInPixels * zoomMultiplier;

    var rotatedDragXDistance = scaledDragDistanceInPixels * Math.cos(dragAngle - rotationY);
    var rotatedDragZDistance = scaledDragDistanceInPixels * Math.sin(dragAngle - rotationY);
    interactiveCamera.setCenterCoordinates(interactiveCamera.centerX() + rotatedDragXDistance, interactiveCamera.centerZ() + rotatedDragZDistance);
  };


  var calculateZoomDelta = function(previousTouchPoints, currentTouchPoints) {
    var previousDistanceBetweenTouches = CityTour.Math.distanceBetweenPoints(previousTouchPoints[0].x, previousTouchPoints[0].z, previousTouchPoints[1].x, previousTouchPoints[1].z);
    var currentDistanceBetweenTouches = CityTour.Math.distanceBetweenPoints(currentTouchPoints[0].x, currentTouchPoints[0].z, currentTouchPoints[1].x, currentTouchPoints[1].z);
    return currentDistanceBetweenTouches - previousDistanceBetweenTouches;
  };

  var touchPointsAreHorizontal = function(angleBetweenTouchPoints) {
    var ALLOWABLE_DELTA_FOR_X_ROTATION = Math.PI / 16;
    var HALF_PI = Math.PI / 2;

    return Math.abs(angleBetweenTouchPoints) >= (HALF_PI - ALLOWABLE_DELTA_FOR_X_ROTATION) &&
           Math.abs(angleBetweenTouchPoints) <= (HALF_PI + ALLOWABLE_DELTA_FOR_X_ROTATION);
  };

  var rotationYActive = function(rotationYDelta) {
    return Math.abs(rotationYDelta) >= 0.01;
  };

  var processMultiTouchGestures = function(currentTouchPoints) {
    var previousAngleBetweenTouches, currentAngleBetweenTouches;
    var yDistanceDelta;
    var rotationAngleDelta;
    var distanceBetweenTouches;

    if (previousTouchPoints.length !== 2) {
      return;
    }

    currentAngleBetweenTouches = Math.atan2(-(currentTouchPoints[1].x - currentTouchPoints[0].x), -(currentTouchPoints[1].z - currentTouchPoints[0].z));

    if (currentGesture === undefined && touchPointsAreHorizontal(currentAngleBetweenTouches)) {
      currentGesture = TILT;
    }

    if (currentGesture === TILT) {
      yDistanceDelta = currentTouchPoints[0].z - previousTouchPoints[0].z;
      interactiveCamera.setTiltPercentage(interactiveCamera.tiltPercentage() + (yDistanceDelta / 100));
    }
    else {
      previousAngleBetweenTouches = Math.atan2(-(previousTouchPoints[1].x - previousTouchPoints[0].x), -(previousTouchPoints[1].z - previousTouchPoints[0].z));
      rotationAngleDelta = previousAngleBetweenTouches - currentAngleBetweenTouches;

      if (rotationYActive(rotationAngleDelta)) {
        currentGesture = ROTATE;
        interactiveCamera.setRotationAngle(interactiveCamera.rotationAngle() + rotationAngleDelta);
      }
      else {
        currentGesture = PINCH_ZOOM;
        distanceBetweenTouches = calculateZoomDelta(previousTouchPoints, currentTouchPoints);
        interactiveCamera.setZoomPercentage(interactiveCamera.zoomPercentage() + (distanceBetweenTouches / 200));
      }
    }
  };

  var processGesture = function(currentTouchPoints) {
    if (currentTouchPoints.length === 1) {
      currentGesture = PAN;
      panCamera(currentTouchPoints);
    }
    else if (currentTouchPoints.length === 2) {
      processMultiTouchGestures(currentTouchPoints);
    }

    previousTouchPoints = currentTouchPoints;
  };

  var enableEventHandlers = function() {
    el.addEventListener('mousedown', onMouseDown, false);
    el.addEventListener('touchstart', onTouchStart, false);
    el.addEventListener('mousemove', onMouseMove, false);
    el.addEventListener('touchmove', onTouchMove, false);
    el.addEventListener('mouseup', onMouseUp, false);
    el.addEventListener('touchend', onTouchEnd, false);

    el.removeEventListener('touchstart', onTouchStartStub, false);
  };

  var disableEventHandlers = function() {
    el.removeEventListener('mousedown', onMouseDown, false);
    el.removeEventListener('touchstart', onTouchStart, false);
    el.removeEventListener('mousemove', onMouseMove, false);
    el.removeEventListener('touchmove', onTouchMove, false);
    el.removeEventListener('mouseup', onMouseUp, false);
    el.removeEventListener('touchend', onTouchEnd, false);

    el.addEventListener('touchstart', onTouchStartStub, false);
  };


  var id1 = messageBroker.addSubscriber("flythrough.started", disableEventHandlers);
  var id2 = messageBroker.addSubscriber("flythrough.stopped", enableEventHandlers);

  onMouseUp();
  enableEventHandlers();
};


var SceneView = function(containerEl, initialWorldConfig, interactiveCamera, messageBroker) {
  var worldData;
  var renderView = null, poleCamera;
  var timer;
  var animationManager;
  var mode = 'interactive';

  var updateCamera = function(data) {
    interactiveCamera.syncCamera(poleCamera);
    renderView.render();
  };

  var startFlythrough = function() {
    animationManager.init(worldData.centerX, worldData.centerZ, poleCamera.positionX(), poleCamera.positionY(), poleCamera.positionZ(), poleCamera.rotationX(), poleCamera.rotationY());
    timer.onTick(1);
    timer.start();
    mode = 'flythrough';
    messageBroker.publish("flythrough.started", {});
  };

  var stopFlythrough = function() {
    timer.togglePause();
    interactiveCamera.syncFromPoleCamera(poleCamera);
    updateCamera();
    mode = 'interactive';
    messageBroker.publish("flythrough.stopped", {});
  };

  var toggleFlythrough = function() {
    if (mode === 'interactive') {
      startFlythrough();
    }
    else {
      stopFlythrough();
    }
  };

  var reset = function(newWorldConfig) {
    worldData = CityTour.WorldGenerator.generate(newWorldConfig);
    var sceneBuilder = new CityTour.Scene.Builder();
    var scene = sceneBuilder.build(worldData.terrain, worldData.roadNetwork, worldData.buildings);

    if (renderView === null) {
      renderView = new CityTour.RenderView(containerEl, scene);
    }
    else {
      renderView.setScene(scene);
    }

    poleCamera = renderView.poleCamera();

    timer = new CityTour.Timer();
    animationManager = new CityTour.AnimationManager(worldData.terrain, worldData.roadNetwork, poleCamera);
    timer.onTick = function(frameCount) {
      animationManager.tick(frameCount);
      renderView.render();
    };

    updateCamera();

    renderView.resize();
    renderView.render();
  };

  reset(initialWorldConfig);
  containerEl.appendChild(renderView.domElement());

  window.addEventListener('resize', renderView.resize, false);
  var id1 = messageBroker.addSubscriber("camera.updated", updateCamera);


  return {
    reset: reset,
    toggleFlythrough: toggleFlythrough,
    domElement: function() { return renderView.domElement(); },
  };
};


var CityConfigService = function() {
  var heightJitter = 20;
  var heightJitterDecay = 0.65;
  var includeRiver = true;
  var safeFromDecayPercentage = 0.4;
  var percentageDistanceDecayBegins = 0.4;
  var maxBuildingStories = 40;

  var toWorldConfig = function() {
    return {
      terrain: {
        heightJitter: heightJitter,
        heightJitterDecay: heightJitterDecay,
        probabilityOfRiver: includeRiver ? 1.0 : 0.0,
      },
      roadNetwork: {
        safeFromDecayPercentage: safeFromDecayPercentage,
      },
      zonedBlocks: {
        percentageDistanceDecayBegins: percentageDistanceDecayBegins,
        maxBuildingStories: maxBuildingStories,
      },
    };
  };


  return {
    heightJitter: function() { return heightJitter; },
    setHeightJitter: function(newHeightJitter) { heightJitter = newHeightJitter; },
    heightJitterDecay: function() { return heightJitterDecay; },
    setHeightJitterDecay: function(newHeightJitterDecay) { heightJitterDecay = newHeightJitterDecay; },
    includeRiver: function() { return includeRiver; },
    setIncludeRiver: function(newIncludeRiver) { includeRiver = newIncludeRiver; },
    safeFromDecayPercentage: function() { return safeFromDecayPercentage; },
    setSafeFromDecayPercentage: function(newSafeFromDecayPercentage) { safeFromDecayPercentage = newSafeFromDecayPercentage; },
    percentageDistanceDecayBegins: function() { return percentageDistanceDecayBegins; },
    setPercentageDistanceDecayBegins: function(newPercentageDistanceDecayBegins) { percentageDistanceDecayBegins = newPercentageDistanceDecayBegins; },
    maxBuildingStories: function() { return maxBuildingStories; },
    setMaxBuildingStories: function(newMaxBuildingStories) { maxBuildingStories = newMaxBuildingStories; },
    toWorldConfig: toWorldConfig,
  };
};


var CityEditorController = function(cityConfigService, sceneView, messageBroker) {
  var container = document.getElementById("city-editor-container");
  var editorToggleButton = document.getElementById("city-editor-toggle");

  var terrainJitter = document.getElementById("terrain-jitter");
  var heightJitterDecay = document.getElementById("terrain-decay");
  var includeRiver = document.getElementById("terrain-river");
  var safeFromDecayPercentage = document.getElementById("roads-decay-distance-percentage");
  var percentageDistanceDecayBegins = document.getElementById("buildings-decay-distance-percentage");
  var maxBuildingStories = document.getElementById("buildings-max-stories");

  var resetButton = document.getElementById("reset");
  var flythroughToggle = document.getElementById("flythrough-toggle");

  var toggleCityEditor = function(e) {
    document.getElementById("city-editor").classList.toggle("display-none");
  };

  var reset = function(e) {
    sceneView.reset(cityConfigService.toWorldConfig());
  };

  var toggleFlythrough = function(e) {
    flythroughToggle.innerText = (flythroughToggle.innerText === "Take a Tour") ? "Stop Tour" : "Take a Tour";

    sceneView.toggleFlythrough();
  };

  var onFlythroughStarted = function(e) {
    container.classList.add("display-none");
  };

  var onFlythroughStopped = function(e) {
    container.classList.remove("display-none");
  };

  terrainJitter.addEventListener('change', function(e) { cityConfigService.setHeightJitter(parseInt(e.target.value)); }, false);
  heightJitterDecay.addEventListener('change', function(e) { cityConfigService.setHeightJitterDecay(parseFloat(e.target.value)); }, false);
  includeRiver.addEventListener('change', function(e) { cityConfigService.setIncludeRiver(e.target.checked); }, false);
  safeFromDecayPercentage.addEventListener('change', function(e) { cityConfigService.setSafeFromDecayPercentage(parseFloat(e.target.value)); }, false);
  percentageDistanceDecayBegins.addEventListener('change', function(e) { cityConfigService.setPercentageDistanceDecayBegins(parseFloat(e.target.value)); }, false);
  maxBuildingStories.addEventListener('change', function(e) { cityConfigService.setMaxBuildingStories(parseInt(e.target.value)); }, false);

  editorToggleButton.addEventListener('click', toggleCityEditor, false);
  resetButton.addEventListener('click', reset, false);
  flythroughToggle.addEventListener('click', toggleFlythrough, false);

  var id1 = messageBroker.addSubscriber("flythrough.started", onFlythroughStarted);
  var id2 = messageBroker.addSubscriber("flythrough.stopped", onFlythroughStopped);
};


var init = function() {
  var messageBroker = new CityTour.MessageBroker();
  var interactiveCamera = new InteractiveCamera(messageBroker);
  var cityConfigService = new CityConfigService();
  var sceneView = new SceneView(document.getElementById("container"), cityConfigService.toWorldConfig(), interactiveCamera, messageBroker);

  new CityEditorController(cityConfigService, sceneView, messageBroker);
  new NavigationController(interactiveCamera, messageBroker);
  new NavigationTouchController(sceneView.domElement(), interactiveCamera, messageBroker);
};
init();
</script>
</html>
