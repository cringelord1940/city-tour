<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>City Tour Interactive</title>
    <style>
html {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  height: 100%;
  font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Helvetica", arial, sans-serif;
  font-size: 16px;
  line-height: 1.5rem;
  color: #2a2b2b;
}

label {
  width: 6.0rem;
  display: inline-block;
}

h3 {
  font-size: 1.25rem;
  margin: 0;
}

.section {
  margin-bottom: 1.5rem;
}

input[type="range"] {
  vertical-align: sub;
}

.control-legend {
  display: inline-block;
  width: 1.5rem;
  text-align: center;
}

.full-width { width: 100%; }
.full-height { height: 100%; }
.relative { position: relative; }
.absolute { position: absolute; }
.block { display: block; }
.display-none { display: none; }
.center { text-align: center; }
.no-underline { text-decoration: none; }
    </style>
</head>
<body>
  <div id="container" class="full-width full-height">
    <div class="absolute" style="top: 0; right: 0; background: #fff; padding: 1.5rem;">
      <div style="overflow: auto;">
        <a id="city-editor-toggle" href="#" class="no-underline" style="float: right; color: #000;">â˜°</a>
      </div>
      <div id="city-editor" class="display-none">
        <div class="section">
          <h3>Terrain</h3>
          <span class="block">
            <label>Jitter</label>
            <span class="control-legend">&minus;</span>
            <input id="terrain-jitter" type="range" value="20" min="0" max="100" step="1" />
            <span class="control-legend">+</span>
          </span>
          <span class="block">
            <label>Decay</label>
            <span class="control-legend">&minus;</span>
            <input id="terrain-decay" type="range" value="0.65" min="0.0" max="1.0" step="0.01" />
            <span class="control-legend">+</span>
          </span>
          <span class="block">
            <label>River</label>
            <input id="terrain-river" type="checkbox" checked />
          </span>
        </div>

        <div class="section">
          <h3>Roads</h3>
          <span class="block">
            <label>Decay</label>
            <span class="control-legend">&minus;</span>
            <input id="roads-decay-distance-percentage" type="range" value="0.4" min="0.0" max="0.99" step="0.01" />
            <span class="control-legend">+</span>
          </span>
        </div>

        <div class="section">
          <h3>Buildings</h3>
          <span class="block">
            <label>Max Stories</label>
            <span class="control-legend">&minus;</span>
            <input id="buildings-max-stories" type="range" value="40" min="1" max="80" step="1" />
            <span class="control-legend">+</span>
          </span>
          <span class="block">
            <label>Density</label>
            <span class="control-legend">&minus;</span>
            <input id="buildings-decay-distance-percentage" type="range" value="0.4" min="0.0" max="1.0" step="0.01" />
            <span class="control-legend">+</span>
          </span>
        </div>

        <span class="block center">
          <button id="reset" style="margin-left: auto; margin-right: auto;">Create New City</button>
        </span>
      </div>
    </div>


    <div class="absolute" style="bottom: 0; right: 0; background: #fff; padding: 1.5rem;">
      <span class="block" style="display: none;">
        <label>X:</label>
        <input id="centerX" type="range" value="0.0" min="-1000.0" max="1000.0" step="0.1" />
      </span>
      <span class="block" style="display: none;">
        <label>Z:</label>
        <input id="centerZ" type="range" value="0.0" min="-1000.0" max="1000.0" step="0.1" />
      </span>
      <span class="block">
        <label>Rotation</label>
        <span class="control-legend">&olarr;</span>
        <input id="rotationY" type="range" value="-0.5235987755983" min="-3.141592653589793" max="3.141592653589793" step="0.001" />
        <span class="control-legend">&orarr;</span>
      </span>
      <span class="block">
        <label>Tilt</label>
        <span class="control-legend">&rarr;</span>
        <input id="rotationX" type="range" value="0.2" min="0.0" max="1.0" step="0.001" />
        <span class="control-legend">&darr;</span>
      </span>
      <span class="block">
        <label>Zoom</label>
        <span class="control-legend">&minus;</span>
        <input id="zoom" type="range" value="0.0" min="0.0" max="1.0" step="0.01" />
        <span class="control-legend">+</span>
      </span>
    </div>
  </div>
</body>
<script src="lib/three-v86.min.js" type="text/javascript"></script>
<script src="lib/analytics.js" type="text/javascript"></script>
<script src="city_tour.js" type="text/javascript"></script>
<script type="text/javascript">
"use strict";

var generateWorldData = function() {
  var GENERATE_BUILDINGS = true;

  var combinedStartTime = new Date();

  var terrainConfig = {
    heightJitter: parseInt(document.getElementById("terrain-jitter").value),
    heightJitterDecay: parseFloat(document.getElementById("terrain-decay").value),
    river: document.getElementById("terrain-river").checked,
  };

  var terrainStartTime = new Date();
  var terrain = CityTour.TerrainGenerator.generate(CityTour.Config.TERRAIN_COLUMNS, CityTour.Config.TERRAIN_ROWS, terrainConfig);
  var terrainEndTime = new Date();

  var centerX = 0, centerZ = 0;
  while(terrain.materialAtCoordinates(centerX, centerZ) != CityTour.Terrain.LAND) {
    centerZ -= 1;
  }

  var roadConfig = {
    centerMapX: centerX,
    centerMapZ: centerZ,
    safeFromDecayPercentage: parseFloat(document.getElementById("roads-decay-distance-percentage").value),
  };

  var roadStartTime = new Date();
  var roadNetwork = CityTour.RoadNetworkGenerator.generate(terrain, roadConfig);
  var roadEndTime = new Date();

  var zonedBlockConfig = {
    percentageDistanceDecayBegins: parseFloat(document.getElementById("buildings-decay-distance-percentage").value),
    maxBuildingStories: parseInt(document.getElementById("buildings-max-stories").value),
  };

  var zonedBlocksStartTime = new Date();
  var zonedBlocks = (GENERATE_BUILDINGS) ? CityTour.ZonedBlockGenerator.generate(terrain, roadNetwork, centerX, centerZ, zonedBlockConfig) : false;
  var zonedBlocksEndTime = new Date();
  var buildingsStartTime = new Date();
  var buildings = (GENERATE_BUILDINGS) ? CityTour.BuildingsGenerator.generate(terrain, zonedBlocks) : false;
  var buildingsEndTime = new Date();

  var combinedEndTime = new Date();

  console.log("Time to generate world data: " + (combinedEndTime - combinedStartTime) + "ms");
  console.log("  Terrain:      " + (terrainEndTime - terrainStartTime) + "ms");
  console.log("  Road Network: " + (roadEndTime - roadStartTime) + "ms");
  console.log("  Lots:         " + (zonedBlocksEndTime - zonedBlocksStartTime) + "ms");
  console.log("  Buildings:    " + (buildingsEndTime - buildingsStartTime) + "ms");

  return {
    terrain: terrain,
    roadNetwork: roadNetwork,
    buildings: buildings,
    centerX: centerX,
    centerZ: centerZ,
  };
};


var MessageBroker = function() {
  var uniqueID = -1;
  var subscribers = {};

  var addSubscriber = function(topic, func) {
    if (!subscribers[topic]) {
      subscribers[topic] = [];
    }

    uniqueID += 1;

    subscribers[topic].push({ id: uniqueID, func: func });
    return uniqueID;
  };

  var removeSubscriber = function(topic, id) {
    if (subscribers[topic]) {
      subscribers[topic].forEach(function(item, index) {
        if (item.id === id) {
          subscribers[topic].splice(index, 1);
          return true;
        }
      });
    }

    return false;
  };

  var publish = function(topic, data) {
    if (!subscribers[topic] || subscribers[topic] === []) {
      console.log("Warning: No listeners for topic " + topic);
    }
    else {
      subscribers[topic].forEach(function(entry) {
        entry.func(data);
      });
    }
  };


  return {
    addSubscriber:    addSubscriber,
    removeSubscriber: removeSubscriber,
    publish:          publish,
  };
};

var messageBroker = new MessageBroker();


var MapCamera = function(messageBroker) {
  var MIN_CENTER_X = -1000.0;
  var MAX_CENTER_X = 1000.0;

  var MIN_CENTER_Z = -1000.0;
  var MAX_CENTER_Z = 1000.0;

  var MIN_TILT_ANGLE = -1.5707963267949;
  var MAX_TILT_ANGLE = -0.1;

  var MIN_ZOOM_DISTANCE = 20.0;
  var MAX_ZOOM_DISTANCE = 1000.0;

  var centerX = 0.0;
  var centerZ = 0.0;
  var zoomPercentage = 0.0;
  var tiltPercentage = 0.2;
  var rotationAngle = 0.0;

  var clamp = function(value, min, max) {
    return Math.max(min, Math.min(max, value));
  };

  var mapCamera = {};

  mapCamera.centerX = function() { return centerX; };
  mapCamera.setCenterX = function(newCenterX) {
    centerX = clamp(newCenterX, MIN_CENTER_X, MAX_CENTER_X);
    messageBroker.publish("camera.updated", {});
  };

  mapCamera.centerZ = function() { return centerZ; };
  mapCamera.setCenterZ = function(newCenterZ) {
    centerZ = clamp(newCenterZ, MIN_CENTER_Z, MAX_CENTER_Z);
    messageBroker.publish("camera.updated", {});
  };

  mapCamera.zoomPercentage = function() { return zoomPercentage; };
  mapCamera.setZoomPercentage = function(newZoomPercentage) {
    zoomPercentage = clamp(newZoomPercentage, 0.0, 1.0);
    messageBroker.publish("camera.updated", {});
  };

  mapCamera.tiltPercentage = function() { return tiltPercentage; };
  mapCamera.setTiltPercentage = function(newTiltPercentage) {
    tiltPercentage = clamp(newTiltPercentage, 0.0, 1.0);
    messageBroker.publish("camera.updated", {});
  };

  mapCamera.rotationAngle = function() { return rotationAngle; };
  mapCamera.setRotationAngle = function(newRotationAngle) {
    rotationAngle = newRotationAngle;
    messageBroker.publish("camera.updated", {});
  };


  /*    C
       /|
      / |
     /  |
    X----

  X == Map center point
  C == Camera position
  rotationX == angle X == angle between camera and center point
  Hypotenuse == Zoom == Distance of camera from center point
  Opposite == Height of camera off the ground
  Adjacent == X/Z distance of camera from center point
  rotationY == rotation of this triangle around y-axis of center point
  */
  mapCamera.syncCamera = function(poleCamera) {
    var tiltAngle = CityTour.Math.lerp(MAX_TILT_ANGLE, MIN_TILT_ANGLE, tiltPercentage);
    var zoom = CityTour.Math.lerp(MAX_ZOOM_DISTANCE, MIN_ZOOM_DISTANCE, zoomPercentage);

    var hypotenuse = zoom;
    var adjacent = Math.cos(tiltAngle) * hypotenuse;
    var opposite = -(Math.sin(tiltAngle) * hypotenuse);

    poleCamera.setPositionX(centerX + (adjacent * Math.sin(rotationAngle)));
    poleCamera.setPositionY(opposite);
    poleCamera.setPositionZ(centerZ + (adjacent * Math.cos(-rotationAngle)));
    poleCamera.setRotationX(tiltAngle);
    poleCamera.setRotationY(rotationAngle);
  };

  return mapCamera;
};
var mapCamera = new MapCamera(messageBroker);

var NavigationController = function(messageBroker) {
  var centerXControl = document.getElementById("centerX");
  var centerZControl = document.getElementById("centerZ");
  var rotationYControl = document.getElementById("rotationY");
  var rotationXControl = document.getElementById("rotationX");
  var zoomControl = document.getElementById("zoom");

  var render = function(data) {
    centerXControl.value = mapCamera.centerX();
    centerZControl.value = mapCamera.centerZ();
    rotationYControl.value = mapCamera.rotationAngle();
    rotationXControl.value = mapCamera.tiltPercentage();
    zoomControl.value = mapCamera.zoomPercentage();
  };

  var setCenterX = function(e) {
    mapCamera.setCenterX(parseFloat(centerXControl.value));
  };
  var setCenterZ = function(e) {
    mapCamera.setCenterZ(parseFloat(centerZControl.value));
  };
  var setRotationAngle = function(e) {
    mapCamera.setRotationAngle(parseFloat(rotationYControl.value));
  };
  var setTiltAngle = function(e) {
    mapCamera.setTiltPercentage(parseFloat(rotationXControl.value));
  };
  var setZoomPercentage = function(e) {
    mapCamera.setZoomPercentage(parseFloat(zoomControl.value));
  };

  centerXControl.addEventListener('input', setCenterX, false);
  centerZControl.addEventListener('input', setCenterZ, false);
  rotationYControl.addEventListener('input', setRotationAngle, false);
  rotationXControl.addEventListener('input', setTiltAngle, false);
  zoomControl.addEventListener('input', setZoomPercentage, false);

  render({});

  var id1 = messageBroker.addSubscriber("camera.updated", render);
};


var NavigationTouchController = function(el) {
  var startMouseDrag = function(e) {
    dragInProgress = true;
    previousDragsX = [e.clientX];
    previousDragsZ = [e.clientY];
  };

  var startTouchDrag = function(e) {
    var i, touch;

    dragInProgress = true;

    previousDragsX = [];
    previousDragsZ = [];
    for (i = 0; i < e.touches.length; i++) {
      touch = e.touches.item(i);
      previousDragsX.push(touch.clientX);
      previousDragsZ.push(touch.clientY);
    }

    e.preventDefault();
  };

  var mouseDrag = function(e) {
    if (!dragInProgress) {
      return;
    }

    var currentDragsX = [e.clientX];
    var currentDragsZ = [e.clientY];

    drag(currentDragsX, currentDragsZ);
  };

  var touchDrag = function(e) {
    var i, touch;
    var currentDragsX, currentDragsZ;

    if (!dragInProgress) {
      return;
    }

    currentDragsX = [];
    currentDragsZ = [];
    for (i = 0; i < e.touches.length; i++) {
      touch = e.touches.item(i);
      currentDragsX.push(touch.clientX);
      currentDragsZ.push(touch.clientY);
    }

    drag(currentDragsX, currentDragsZ);
  };

  var syncPan = function(currentDragsX, currentDragsZ) {
    var rotationY = mapCamera.rotationAngle();
    var dragXDistanceInPixels = currentDragsX[0] - previousDragsX[0];
    var dragZDistanceInPixels = currentDragsZ[0] - previousDragsZ[0];
    var totalDragDistanceInPixels = Math.sqrt((dragXDistanceInPixels * dragXDistanceInPixels) + (dragZDistanceInPixels * dragZDistanceInPixels));
    var dragAngle = Math.atan2(-dragZDistanceInPixels, -dragXDistanceInPixels);

    var rotatedDragXDistance = totalDragDistanceInPixels * Math.cos(dragAngle - rotationY);
    var rotatedDragZDistance = totalDragDistanceInPixels * Math.sin(dragAngle - rotationY);

    mapCamera.setCenterX(mapCamera.centerX() + rotatedDragXDistance);
    mapCamera.setCenterZ(mapCamera.centerZ() + rotatedDragZDistance);
  };

  var syncZoom = function(currentDragsX, currentDragsZ) {
    if (previousDragsX.length !== 2) {
      return;
    }

    // Zoom
    var previousDistanceBetweenTouches = CityTour.Math.distanceBetweenPoints(previousDragsX[0], previousDragsZ[0], previousDragsX[1], previousDragsZ[1]);
    var currentDistanceBetweenTouches = CityTour.Math.distanceBetweenPoints(currentDragsX[0], currentDragsZ[0], currentDragsX[1], currentDragsZ[1]);
    var distanceDelta = currentDistanceBetweenTouches - previousDistanceBetweenTouches;

    var newZoomPercentage = mapCamera.zoomPercentage() + (distanceDelta / 200);
    mapCamera.setZoomPercentage(newZoomPercentage);


    var previousAngleBetweenTouches = Math.atan2(-(previousDragsX[1] - previousDragsX[0]), -(previousDragsZ[1] - previousDragsZ[0]));
    var currentAngleBetweenTouches = Math.atan2(-(currentDragsX[1] - currentDragsX[0]), -(currentDragsZ[1] - currentDragsZ[0]));
    var angleDelta = previousAngleBetweenTouches - currentAngleBetweenTouches;

    var ALLOWABLE_DELTA_FOR_X_ROTATION = Math.PI / 16;
    var HALF_PI = Math.PI / 2;
    if (Math.abs(currentAngleBetweenTouches) >= (HALF_PI - ALLOWABLE_DELTA_FOR_X_ROTATION) &&
        Math.abs(currentAngleBetweenTouches) <= (HALF_PI + ALLOWABLE_DELTA_FOR_X_ROTATION)) {
      var yDistanceDelta = currentDragsZ[0] - previousDragsZ[0];
      var newTiltPercentage = mapCamera.tiltPercentage() + (yDistanceDelta / 100);
      mapCamera.setTiltPercentage(newTiltPercentage);
    }
    else {
      // Y Rotation
      var newRotationAngle = mapCamera.rotationAngle() + angleDelta;
      mapCamera.setRotationAngle(newRotationAngle);
    }
  };

  var drag = function(currentDragsX, currentDragsZ) {
    if (currentDragsX.length === 1) {
      syncPan(currentDragsX, currentDragsZ);
    }
    else if (currentDragsX.length === 2) {
      syncZoom(currentDragsX, currentDragsZ);
    }

    previousDragsX = currentDragsX;
    previousDragsZ = currentDragsZ;
  };

  var stopDrag = function(e) {
    dragInProgress = false;
    previousDragsX = [];
    previousDragsZ = [];
  };

  var dragInProgress;
  var previousDragsX;
  var previousDragsZ;
  stopDrag();

  el.addEventListener('mousedown', startMouseDrag, false);
  el.addEventListener('touchstart', startTouchDrag, false);
  el.addEventListener('mousemove', mouseDrag, false);
  el.addEventListener('touchmove', touchDrag, false);
  el.addEventListener('mouseup', stopDrag, false);
  el.addEventListener('touchend', stopDrag, false);
};


var init = function() {
  var container = document.getElementById("container");
  var renderView = null, poleCamera;

  var updateCamera = function(data) {
    mapCamera.syncCamera(poleCamera);
    renderView.render();
  };

  var id1 = messageBroker.addSubscriber("camera.updated", updateCamera);

  var reset = function() {
    var worldData = generateWorldData();

    var sceneBuilder = new CityTour.Scene.Builder();
    var scene = sceneBuilder.build(worldData.terrain, worldData.roadNetwork, worldData.buildings);

    if (renderView === null) {
      renderView = new CityTour.RenderView(container, scene);
    }
    else {
      renderView.setScene(scene);
    }

    poleCamera = renderView.poleCamera();

    updateCamera();

    renderView.resize();
    renderView.render();
  };

  reset();
  container.appendChild(renderView.domElement());

  new NavigationController(messageBroker);
  new NavigationTouchController(renderView.domElement());

  window.addEventListener('resize', renderView.resize, false);

  var resetButton = document.getElementById("reset");
  resetButton.addEventListener('click', reset, false);

  var toggleCityEditor = function(e) {
    document.getElementById("city-editor").classList.toggle("display-none");
  };

  document.getElementById("city-editor-toggle").addEventListener('click', toggleCityEditor, false);
};

init();
</script>
</html>
